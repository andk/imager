/*
Render utilities
*/
#include "imager.h"

#define RENDER_MAGIC 0x765AE

typedef void (*render_color_f)(i_render *, int, int, int, unsigned char const *src, i_color const *color);

#code

static void IM_SUFFIX(render_color_alpha)(i_render *r, int x, int y, int width, unsigned char const *src, i_color const *color);
static void IM_SUFFIX(render_color_13)(i_render *r, int x, int y, int width, unsigned char const *src, i_color const *color);

static render_color_f IM_SUFFIX(render_color_tab)[] =
  {
    NULL,
    IM_SUFFIX(render_color_13),
    IM_SUFFIX(render_color_alpha),
    IM_SUFFIX(render_color_13),
    IM_SUFFIX(render_color_alpha),
  };

static void IM_SUFFIX(combine_line_noalpha)(int channels, IM_COLOR *out, IM_COLOR const *in, int count);
static void IM_SUFFIX(combine_line_alpha)(int channels, IM_COLOR *out, IM_COLOR const *in, int count);

#/code

void
i_render_init(i_render *r, i_img *im, int width) {
  r->magic = RENDER_MAGIC;
  r->im = im;
  r->line_width = width;
  r->line_8 = NULL;
  r->line_double = NULL;
  r->fill_width = width;
  r->fill_line_8 = NULL;
  r->fill_line_double = NULL;
}

void
i_render_done(i_render *r) {
  if (r->line_8)
    myfree(r->line_8);
  if (r->line_double)
    myfree(r->line_double);
  if (r->fill_line_8)
    myfree(r->fill_line_8);
  if (r->fill_line_double)
    myfree(r->fill_line_double);
  r->magic = 0;
}

static void
alloc_line(i_render *r, int width, int eight_bit) {
  if (width > r->line_width) {
    int new_width = r->line_width * 2;
    if (new_width < width)
      new_width = width;

    if (eight_bit) {
      if (r->line_8)
	r->line_8 = myrealloc(r->line_8, sizeof(i_color) * new_width);
      else
	r->line_8 = mymalloc(sizeof(i_color) * new_width);
      if (r->line_double) {
	myfree(r->line_double);
	r->line_double = NULL;
      }
    }
    else {
      if (r->line_double)
	r->line_double = myrealloc(r->line_double, sizeof(i_fcolor) * new_width);
      else
	r->line_double = mymalloc(sizeof(i_fcolor) * new_width);
      if (r->line_8) {
	myfree(r->line_8);
	r->line_double = NULL;
      }
    }

    r->line_width = new_width;
  }
  else {
    if (eight_bit) {
      if (!r->line_8)
	r->line_8 = mymalloc(sizeof(i_color) * r->line_width);
      if (r->line_double) {
	myfree(r->line_double);
	r->line_double = NULL;
      }
    }
    else {
      if (!r->line_double)
	r->line_double = mymalloc(sizeof(i_fcolor) * r->line_width);
      if (r->line_8) {
	myfree(r->line_8);
	r->line_8 = NULL;
      }
    }
  }
}

static void
alloc_fill_line(i_render *r, int width, int eight_bit) {
  if (width > r->fill_width) {
    int new_width = r->fill_width * 2;
    if (new_width < width)
      new_width = width;

    if (eight_bit) {
      if (r->line_8)
	r->fill_line_8 = myrealloc(r->fill_line_8, sizeof(i_color) * new_width);
      else
	r->fill_line_8 = mymalloc(sizeof(i_color) * new_width);
      if (r->fill_line_double) {
	myfree(r->fill_line_double);
	r->fill_line_double = NULL;
      }
    }
    else {
      if (r->fill_line_double)
	r->fill_line_double = myrealloc(r->fill_line_double, sizeof(i_fcolor) * new_width);
      else
	r->fill_line_double = mymalloc(sizeof(i_fcolor) * new_width);
      if (r->fill_line_8) {
	myfree(r->fill_line_8);
	r->fill_line_double = NULL;
      }
    }

    r->fill_width = new_width;
  }
  else {
    if (eight_bit) {
      if (!r->fill_line_8)
	r->fill_line_8 = mymalloc(sizeof(i_color) * r->fill_width);
      if (r->fill_line_double) {
	myfree(r->fill_line_double);
	r->fill_line_double = NULL;
      }
    }
    else {
      if (!r->fill_line_double)
	r->fill_line_double = mymalloc(sizeof(i_fcolor) * r->fill_width);
      if (r->fill_line_8) {
	myfree(r->fill_line_8);
	r->fill_line_8 = NULL;
      }
    }
  }
}

void
i_render_color(i_render *r, int x, int y, int width, unsigned char const *src,
               i_color const *color) {
  i_img *im = r->im;
  if (y < 0 || y >= im->ysize)
    return;
  if (x < 0) {
    width += x;
    src -= x;
    x = 0;
  }
  if (x + width > im->xsize) {
    width = im->xsize - x;
  }
  if (x >= im->xsize || x + width <= 0 || width <= 0)
    return;

  /* avoid as much work as we can */
  while (width > 0 && *src == 0) {
    --width;
    ++src;
    ++x;
  }
  while (width > 0 && src[width-1] == 0) {
    --width;
  }
  if (!width)
    return;

#if 0
  /* make sure our line buffer is big enough */
  if (width > r->width) {
    int new_width = r->width * 2;
    if (new_width < width)
      new_width = width;

    if (r->im->bits <= 8) {
      if (r->line_8)
	r->line_8 = myrealloc(r->line_8, sizeof(i_color) * new_width);
      else
	r->line_8 = mymalloc(sizeof(i_color) * new_width);
      if (r->line_double) {
	myfree(r->line_double);
	r->line_double = NULL;
      }
    }
    else {
      if (r->line_double)
	r->line_double = myrealloc(r->line_double, sizeof(i_fcolor) * new_width);
      else
	r->line_double = mymalloc(sizeof(i_fcolor) * new_width);
      if (r->line_8) {
	myfree(r->line_8);
	r->line_double = NULL;
      }
    }

    r->width = new_width;
  }
#else
  alloc_line(r, width, r->im->bits <= 8);
#endif

#code r->im->bits <= 8
  /*if (r->IM_SUFFIX(line) == NULL)
    r->IM_SUFFIX(line) = mymalloc(sizeof(IM_COLOR) * r->width);*/
  (IM_SUFFIX(render_color_tab)[im->channels])(r, x, y, width, src, color);
#/code
}

void
i_render_fill(i_render *r, int x, int y, int width, unsigned char const *src,
	      i_fill_t *fill) {
  i_img *im = r->im;
  int fill_channels = im->channels;
  
  if (fill_channels == 1 || fill_channels == 3)
    ++fill_channels;

  if (y < 0 || y >= im->ysize)
    return;
  if (x < 0) {
    width += x;
    src -= x;
    x = 0;
  }
  if (x + width > im->xsize) {
    width = im->xsize - x;
  }
  if (x >= im->xsize || x + width <= 0 || width <= 0)
    return;

  if (src) {
    /* avoid as much work as we can */
    while (width > 0 && *src == 0) {
      --width;
      ++src;
      ++x;
    }
    while (width > 0 && src[width-1] == 0) {
      --width;
    }
  }
  if (!width)
    return;

#if 0
  if (r->im->bits <= 8 && fill->f_fill_with_color) {
    if (!r->line_8)
      r->line_8 = mymalloc(sizeof(i_color) * r->width);
    if (!r->fill_line_8)
      r->fill_line_8 = mymalloc(sizeof(i_color) * r->width);
  }
  else {
    if (!r->line_double)
      r->line_double = mymalloc(sizeof(i_fcolor) * r->width);
    if (!r->fill_line_double)
      r->fill_line_double = mymalloc(sizeof(i_fcolor) * r->width);
  }

  /* make sure our line buffer is big enough */
  if (width > r->width) {
    int new_width = r->width * 2;
    if (new_width < width)
      new_width = width;

    if (r->im->bits <= 8 && fill->f_fill_with_color) {
      r->line_8 = myrealloc(r->line_8, sizeof(i_color) * new_width);
      r->fill_line_8 = myrealloc(r->fill_line_8, sizeof(i_color) * new_width);
      if (r->line_double) {
	myfree(r->line_double);
	r->line_double = NULL;
      }
      if (r->fill_line_double) {
	myfree(r->fill_line_double);
	r->fill_line_double = NULL;
      }
    }
    else {
      r->line_double = myrealloc(r->line_double, sizeof(i_fcolor) * new_width);
      r->fill_line_double = myrealloc(r->fill_line_double, sizeof(i_fcolor) * new_width);
      if (r->line_8) {
	myfree(r->line_8);
	r->line_8 = NULL;
      }
      if (r->fill_line_8) {
	myfree(r->fill_line_8);
	r->fill_line_8 = NULL;
      }
    }
    r->width = new_width;
  }
#else
  alloc_line(r, width, r->im->bits <= 8 && fill->f_fill_with_color != NULL);
  alloc_fill_line(r, width, r->im->bits <= 8 && fill->f_fill_with_color != NULL);
#endif

#code r->im->bits <= 8 && fill->f_fill_with_color
  if (IM_FILL_COMBINE(fill)) {
    IM_COLOR *srcc = r->IM_SUFFIX(fill_line);
    IM_COLOR *destc = r->IM_SUFFIX(line);
    IM_FILL_FILLER(fill)(fill, x, y, width, fill_channels, r->IM_SUFFIX(fill_line));
    if (src) {
      unsigned char const *srcc = src;
      IM_COLOR *fillc = r->IM_SUFFIX(fill_line);
      int work_width = width;
      while (work_width) {
	if (*srcc == 0) {
	  fillc->channel[fill_channels-1] = 0;
	}
	else if (*srcc != 255) {
	  fillc->channel[fill_channels-1] =
	    fillc->channel[fill_channels-1] * *srcc / 255;
	}
	--work_width;
	++srcc;
	++fillc;
      }
    }
    IM_GLIN(r->im, x, x+width, y, r->IM_SUFFIX(line));
    IM_FILL_COMBINE(fill)(destc, srcc, fill_channels, width);
    switch (im->channels) {
    case 1:
    case 3:
      IM_SUFFIX(combine_line_noalpha)(im->channels, r->IM_SUFFIX(line), r->IM_SUFFIX(fill_line), width);
      break;
      
    case 2:
    case 4:
      IM_SUFFIX(combine_line_alpha)(im->channels, r->IM_SUFFIX(line), r->IM_SUFFIX(fill_line), width);
      break;
      
    default:
      i_fatal(3, "Invalid channel count %d\n", im->channels);
    }
  }
  else {
    if (src) {
      int work_width = width;
      IM_COLOR *srcc = r->IM_SUFFIX(fill_line);
      IM_COLOR *destc = r->IM_SUFFIX(line);
      int ch;

      IM_FILL_FILLER(fill)(fill, x, y, width, fill_channels, r->IM_SUFFIX(fill_line));
      IM_GLIN(r->im, x, x+width, y, r->IM_SUFFIX(line));
      while (work_width) {
	if (*src == 255) {
	  /* just replace it */
	  *destc = *srcc;
	}
	else if (*src) {
	  for (ch = 0; ch < im->channels; ++ch) {
	    IM_WORK_T work = (destc->channel[ch] * (IM_SAMPLE_MAX - *src)
			      + srcc->channel[ch] * *src) / IM_SAMPLE_MAX;
	    destc->channel[ch] = IM_LIMIT(work);
	  }
	}
	
	++srcc;
	++destc;
	++src;
	--work_width;
      }
    }
    else { /* if (src) */
      IM_FILL_FILLER(fill)(fill, x, y, width, r->im->channels, r->IM_SUFFIX(line));
    }
  }
  IM_PLIN(im, x, x+width, y, r->IM_SUFFIX(line));
#/code
}

static void
dump_src(const char *note, unsigned char const *src, int width) {
  int i;
  printf("%s - %p/%d\n", note, src, width);
  for (i = 0; i < width; ++i) {
    printf("%02x ", src[i]);
  }
  putchar('\n');
}

#code

void
IM_RENDER_LINE(i_render *r, int x, int y, int width, const IM_SAMPLE_T *src,
	      IM_COLOR *line, IM_FILL_COMBINE_F combine) {
  i_img *im = r->im;
  int src_chans = im->channels;

  /* src must always have an alpha channel */
  if (src_chans == 1 || src_chans == 3)
    ++src_chans;

  if (y < 0 || y >= im->ysize)
    return;
  if (x < 0) {
    src -= x;
    line -= x;
    width += x;
    x = 0;
  }
  if (x + width > im->xsize)
    width = r->im->xsize - x;

#ifdef IM_EIGHT_BIT
  alloc_line(r, width, 1);
#else
  alloc_line(r, width, 0);
#endif

  if (combine) {
    if (src) {
      int work_width = width;
      IM_COLOR *linep = line;
      const IM_SAMPLE_T *srcp = src;
      int alpha_chan = src_chans - 1;
      
      while (work_width) {
	if (*srcp) {
	  if (*srcp != IM_SAMPLE_MAX) 
	    linep->channel[alpha_chan] = 
	      linep->channel[alpha_chan] * *srcp / IM_SAMPLE_MAX;
	}
	else {
	  linep->channel[alpha_chan] = 0;
	}
	--work_width;
	++srcp;
	++linep;
      }
    }
    IM_GLIN(im, x, x+width, y, r->IM_SUFFIX(line));
    combine(r->IM_SUFFIX(line), line, im->channels, width);
    switch (im->channels) {
    case 1:
    case 3:
      IM_SUFFIX(combine_line_noalpha)(im->channels, r->IM_SUFFIX(line),
				      line, width);
      break;
      
    case 2:
    case 4:
      IM_SUFFIX(combine_line_alpha)(im->channels, r->IM_SUFFIX(line), 
				    line, width);
      break;
      
    default:
      i_fatal(3, "Invalid channel count %d\n", im->channels);
    }
    IM_PLIN(im, x, x+width, y, r->IM_SUFFIX(line));
  }
  else {
    if (src) {
      int work_width = width;
      IM_COLOR *srcc = line;
      IM_COLOR *destc = r->IM_SUFFIX(line);

      IM_GLIN(im, x, x+width, y, r->IM_SUFFIX(line));
      while (work_width) {
	if (*src == 255) {
	  /* just replace it */
	  *destc = *srcc;
	}
	else if (*src) {
	  int ch;
	  for (ch = 0; ch < im->channels; ++ch) {
	    IM_WORK_T work = (destc->channel[ch] * (IM_SAMPLE_MAX - *src)
			      + srcc->channel[ch] * *src) / IM_SAMPLE_MAX;
	    destc->channel[ch] = IM_LIMIT(work);
	  }
	}
	
	++srcc;
	++destc;
	++src;
	--work_width;
      }
      IM_PLIN(im, x, x+width, y, r->IM_SUFFIX(line));
    }
    else {
      IM_PLIN(im, x, x+width, y, line);
    }
  }
}

static
void
IM_SUFFIX(render_color_13)(i_render *r, int x, int y, int width, 
                unsigned char const *src, i_color const *color) {
  i_img *im = r->im;
  IM_COLOR *linep = r->IM_SUFFIX(line);
  int ch, channels = im->channels;
  int fetch_offset;
#undef STORE_COLOR
#ifdef IM_EIGHT_BIT
#define STORE_COLOR (*color)
#else
  i_fcolor fcolor;

  for (ch = 0; ch < channels; ++ch) {
    fcolor.channel[ch] = color->channel[ch] / 255.0;
  }
#define STORE_COLOR fcolor
#endif
 
  fetch_offset = 0;
  while (fetch_offset < width && *src == 0xFF) {
    *linep++ = STORE_COLOR;
    ++src;
    ++fetch_offset;
  }
  IM_GLIN(im, x+fetch_offset, x+width, y, linep);
  while (fetch_offset < width) {
#ifdef IM_EIGHT_BIT
    IM_WORK_T alpha = *src++;
#else
    IM_WORK_T alpha = *src++ / 255.0;
#endif
    if (alpha == IM_SAMPLE_MAX)
      *linep = STORE_COLOR;
    else if (alpha) {
      for (ch = 0; ch < channels; ++ch) {
        linep->channel[ch] = (linep->channel[ch] * (IM_SAMPLE_MAX - alpha) 
                              + STORE_COLOR.channel[ch] * alpha) / IM_SAMPLE_MAX;
      }
    }
    ++linep;
    ++fetch_offset;
  }
  IM_PLIN(im, x, x+width, y, r->IM_SUFFIX(line));
}

static
void
IM_SUFFIX(render_color_alpha)(i_render *r, int x, int y, int width, 
                unsigned char const *src, i_color const *color) {
  IM_COLOR *linep = r->IM_SUFFIX(line);
  int ch;
  int alpha_channel = r->im->channels - 1;
  int fetch_offset;
#undef STORE_COLOR
#ifdef IM_EIGHT_BIT
#define STORE_COLOR (*color)
#else
  i_fcolor fcolor;

  for (ch = 0; ch < r->im->channels; ++ch) {
    fcolor.channel[ch] = color->channel[ch] / 255.0;
  }
#define STORE_COLOR fcolor
#endif

  fetch_offset = 0;
  while (fetch_offset < width && *src == 0xFF) {
    *linep++ = STORE_COLOR;
    ++src;
    ++fetch_offset;
  }
  IM_GLIN(r->im, x+fetch_offset, x+width, y, linep);
  while (fetch_offset < width) {
#ifdef IM_EIGHT_BIT
    IM_WORK_T src_alpha = *src++;
#else
    IM_WORK_T src_alpha = *src++ / 255.0;
#endif
    if (src_alpha == IM_SAMPLE_MAX)
      *linep = STORE_COLOR;
    else if (src_alpha) {
      IM_WORK_T remains = IM_SAMPLE_MAX - src_alpha;
      IM_WORK_T orig_alpha = linep->channel[alpha_channel];
      IM_WORK_T dest_alpha = src_alpha + (remains * orig_alpha) / IM_SAMPLE_MAX;
      for (ch = 0; ch < alpha_channel; ++ch) {
        linep->channel[ch] = ( src_alpha * STORE_COLOR.channel[ch]
                               + remains * linep->channel[ch] * orig_alpha / IM_SAMPLE_MAX
                               ) / dest_alpha;
      }
      linep->channel[alpha_channel] = dest_alpha;
    }
    ++linep;
    ++fetch_offset;
  }
  IM_PLIN(r->im, x, x+width, y, r->IM_SUFFIX(line));
#undef STORE_COLOR
}

/* combine a line of image data with an output line, both the input
   and output lines include an alpha channel.

   Both input and output lines have I<channels> of data, channels
   should be either 2 or 4.
*/

static void
IM_SUFFIX(combine_line_alpha)(int channels, IM_COLOR *out, IM_COLOR const *in, 
			      int count) {
  int ch;
  int alpha_channel = channels - 1;
  
  while (count) {
    IM_WORK_T src_alpha = in->channel[alpha_channel];
      
    if (src_alpha == IM_SAMPLE_MAX)
      *out = *in;
    else if (src_alpha) {
      IM_WORK_T remains = IM_SAMPLE_MAX - src_alpha;
      IM_WORK_T orig_alpha = out->channel[alpha_channel];
      IM_WORK_T dest_alpha = src_alpha + (remains * orig_alpha) / IM_SAMPLE_MAX;
	
      for (ch = 0; ch < alpha_channel; ++ch) {
	out->channel[ch] = ( src_alpha * in->channel[ch]
			     + remains * out->channel[ch] * orig_alpha / IM_SAMPLE_MAX
			     ) / dest_alpha;
      }
      out->channel[alpha_channel] = dest_alpha;
    }

    ++out;
    ++in;
    --count;
  }
}

/* combine a line of image data with an output line.  The input line
   includes an alpha channel, the output line has no alpha channel.
   
   The input line has I<channels>+1 of color data.  The output line
   has I<channels> of color data.
*/

static void
IM_SUFFIX(combine_line_noalpha)
     (int channels, IM_COLOR *out, IM_COLOR const *in, int count) {
  int ch;

  while (count) {
    IM_WORK_T src_alpha = in->channel[channels];
    
    if (src_alpha == IM_SAMPLE_MAX)
      *out = *in;
    else if (src_alpha) {
      IM_WORK_T remains;
      
      remains = 255 - src_alpha;
      for (ch = 0; ch < channels; ++ch) {
	out->channel[ch] = ( in->channel[ch] * src_alpha
			     + out->channel[ch] * remains) / 255;
      }
    }
    
    ++out;
    ++in;
    --count;
  }
}

#/code
