=head1 NAME

Imager::Files - working with image files

=head1 SYNOPSIS

  my $img = ...;
  $img->write(file=>$filename, type=>$type)
    or die "Cannot write: ",$img->errstr;

  $img = Imager->new;
  $img->read(file=>$filename, type=>$type)
    or die "Cannot read: ", $img->errstr;

  Imager->write_multi({ file=> $filename, ... }, @images)
    or die "Cannot write: ", Imager->errstr;

  my @imgs = Imager->read_multi(file=>$filename)
    or die "Cannot read: ", Imager->errstr;

=head1 DESCRIPTION

You can read and write a variety of images formats, assuming you have
the appropriate libraries, and images can be read or written to/from
files, file handles, file descriptors, scalars, or through callbacks.

To see which image formats Imager is compiled to support the following
code snippet is sufficient:

  use Imager;
  print join " ", keys %Imager::formats;

This will include some other information identifying libraries rather
than file formats.

Reading writing to and from files is simple, use the C<read()>
method to read an image:

  my $img = Imager->new;
  $img->read(file=>$filename, type=>$type)
    or die "Cannot read $filename: ", $img->errstr;

and the C<write()> method to write an image:

  $img->write(file=>$filename, type=>$type)
    or die "Cannot write $filename: ", $img->errstr;

If you're reading from a format that supports multiple images per
file, use the C<read_multi()> method:

  my @imgs = Imager->read_multi(file=>$filename, type=>$type)
    or die "Cannot read $filename: ", Imager->errstr;

and if you want to write multiple images to a single file use the
C<write_multi()> method:

  Imager->write_multi({ file=> $filename, type=>$type }, @images)
    or die "Cannot write $filename: ", Imager->errstr;

If the I<filename> includes an extension that Imager recognizes, then
you don't need the I<type>, but you may want to provide one anyway.
See L</Guessing types> for information on controlling this
recognition.

When you read an image, Imager may set some tags, possibly including
information about the spatial resolution, textual information, and
animation information.  See L</Tags> for specifics.

=head2 Input and output

When reading or writing you can specify one of a variety of sources or
targets:

=over

=item file

The C<file> parameter is the name of the image file to be written to
or read from.  If Imager recognizes the extension of the file you do
not need to supply a C<type>.

=item fh

C<fh> is a file handle, typically either returned from
C<<IO::File->new()>>, or a glob from an C<open> call.  You should call
C<binmode> on the handle before passing it to Imager.

=item fd

C<fd> is a file descriptor.  You can get this by calling the
C<fileno()> function on a file handle, or by using one of the standard
file descriptor numbers.

=item data

When reading data, C<data> is a scalar containing the image file data,
when writing, C<data> is a reference to the scalar to save the image
file data too.  For GIF images you will need giflib 4 or higher, and
you may need to patch giflib to use this option for writing.

=item callback

Imager will make calls back to your supplied coderefs to read, write
and seek from/to/through the image file.

When reading from a file you can use either C<callback> or C<readcb>
to supply the read callback, and when writing C<callback> or
C<writecb> to supply the write callback.

When writing you can also supply the C<maxbuffer> option to set the
maximum amount of data that will be buffered before your write
callback is called.  Note: the amount of data supplied to your
callback can be smaller or larger than this size.

The read callback is called with 2 parameters, the minimum amount of
data required, and the maximum amount that Imager will store in it's C
level buffer.  You may want to return the minimum if you have a slow
data source, or the maximum if you have a fast source and want to
prevent many calls to your perl callback.  The read data should be
returned as a scalar.

Your write callback takes exactly one parameter, a scalar containing
the data to be written.  Return true for success.

The seek callback takes 2 parameters, a I<POSITION>, and a I<WHENCE>,
defined in the same way as perl's seek function.

You can also supply a C<closecb> which is called with no parameters
when there is no more data to be written.  This could be used to flush
buffered data.

=back

=head2 Guessing types

Imager uses the code reference in $Imager::FORMATGUESS to guess the
file type when you don't supply a C<type>.  The code reference is
called with a single parameter, the filename of the file.  The code
reference is only called if a C<file> parameter is supplied to the
file access method.

Return either a valid Imager file type, or undef.

  # I'm writing jpegs to weird filenames
  local $Imager::FORMATGUESS = sub { 'jpeg' };

=head1 TYPE SPECIFIC INFORMATION

The different image formats can write different image type, and some have
different options to control how the images are written.

=head2 PNM (Portable aNy Map)

Imager can write PGM (Portable Gray Map) and PPM (Portable PixMaps)
files, depending on the number of channels in the image.  Currently
the images are written in binary formats.  Only 1 and 3 channel images
can be written, including 1 and 3 channel paletted images.

  $img->write(file=>'foo.ppm') or die $img->errstr;

Imager can read both the ASCII and binary versions of each of the PBM
(Portable BitMap), PGM and PPM formats.

  $img->read(file=>'foo.ppm') or die $img->errstr;

PNM does not support the spatial resolution tags.

=head2 JPEG

You can supply a C<jpegquality> parameter (0-100) when writing a JPEG
file, which defaults to 75%.  Only 1 and 3 channel images
can be written, including 1 and 3 channel paletted images.

  $img->write(file=>'foo.jpg', jpegquality=>90) or die $img->errstr;

Imager will read a grayscale JPEG as a 1 channel image and a color
JPEG as a 3 channel image.

  $img->read(file=>'foo.jpg') or die $img->errstr;

PNM does not support the spatial resolution tags.

=head2 GIF (Graphics Interchange Format)

You can supply many different options when writing to a GIF file, and
you can write a multi-image GIF file, eg. for animation, with the
C<write_multi()> method.

These options can be specified when calling write_multi() or when
writing a single image with the C<gifquant> option set to 'gen'

Note that some viewers will ignore some of these options
(gif_user_input in particular).

=over 4

=item gif_each_palette

Each image in the gif file has it's own palette if this is non-zero.
All but the first image has a local colour table (the first uses the
global colour table.

=item interlace

The images are written interlaced if this is non-zero.

=item gif_delays

A reference to an array containing the delays between images, in 1/100
seconds.

If you want the same delay for every frame you can simply set this to
the delay in 1/100 seconds.

=item gif_user_input

A reference to an array contains user input flags.  If the given flag
is non-zero the image viewer should wait for input before displaying
the next image.

=item gif_disposal

A reference to an array of image disposal methods.  These define what
should be done to the image before displaying the next one.  These are
integers, where 0 means unspecified, 1 means the image should be left
in place, 2 means restore to background colour and 3 means restore to
the previous value.

=item gif_tran_color

A reference to an Imager::Color object, which is the colour to use for
the palette entry used to represent transparency in the palette.  You
need to set the transp option (see L<Quantization options>) for this
value to be used.

=item gif_positions

A reference to an array of references to arrays which represent screen
positions for each image.

=item gif_loop_count

If this is non-zero the Netscape loop extension block is generated,
which makes the animation of the images repeat.

This is currently unimplemented due to some limitations in giflib.

=item gif_eliminate_unused

If this is true, when you write a paletted image any unused colors
will be eliminated from its palette.  This is set by default.

=back

colors parameter on read.

=head2 TIFF (Tagged Image File Format)

=head2 BMP (BitMaP)

=head2 TGA (TarGA)

=cut
